package de.heinerkuecker.constraint;

import java.io.File;
import java.io.IOException;

import de.heinerkuecker.constraint.util.StringUtil;
import de.heinerkuecker.constraint.util.coll.ReadOnlySet;
import de.heinerkuecker.constraint.util.coll.ReadOnlySetAdaptor;
import de.heinerkuecker.constraint.util.lang.SeparatedBuffer;

/**
 * @author Heiner K&uuml;cker
 */
public final class SetConstraintCodeGenerator
{
    /**
     * Postfix 'Set' für Set-Constraint-Klassen
     */
    private static final String SET_CONSTRAINT_CLASS_POSTFIX = 
        "Set";

    /**
     * 
     * @param setConstraintDefinition
     * @param packageName
     * @param importStrArr
     * @param contextObjClassName
     * @param contextObjName
     * @param codegeneratorClassName
     * @param srcDirPackagePathStr
     * @return
     * @throws IOException
     */
    public static <CT> String generateSetConstraintFile(
            final boolean writeToDisc ,
            final SetConstraintDefinition<CT> setConstraintDefinition ,
            final String packageName ,
            final String[] importStrArr ,
            final String contextObjClassName ,
            final String contextObjName ,
            final String codegeneratorClassName ,
            final String srcDirPackagePathStr )
    throws IOException
    {
        final Or<CT> predicateExpression = setConstraintDefinition.predicate;
        
        // Name der zu generierenden Java-Klasse
        final String setConstraintFileName =
                AbstractConstraintCodeGenerator.constraintFileName(
                        predicateExpression ) +
                SET_CONSTRAINT_CLASS_POSTFIX;

        final StringBuilder classStrBldr = new StringBuilder();
        classStrBldr.append( "package " + packageName + ";\n\n" );

        for ( int i = 0 ; importStrArr != null && i < importStrArr.length ; i++ )
        {
            final String importStr = importStrArr[ i ];
            classStrBldr.append( "import " + importStr + ";\n" );
        }

        final String contextObjMemberStr =
                "\t/**\n" +
                "\t * Public context object set of type " + 
                // eventuell vorhandene Grösser- bzw Kleiner-als-Zeichen von Typ-Parametern für Javadoc encoden
                StringUtil.encodeHtml(
                        contextObjClassName ) + ".\n" +
                "\t */\n" +
                "\tpublic final " + ReadOnlySet.class.getName() + "<" + contextObjClassName + "> " + contextObjName + "Set;\n\n" +
                "\t/**\n"
                //inner wird nicht gebraucht: 
                //+
                //"\t * Private context object set of type " + 
                //// eventuell vorhandene Grösser- bzw Kleiner-als-Zeichen von Typ-Parametern für Javadoc encoden
                //StringUtil.encodeHtml(
                //        contextObjClassName ) + ".\n" +
                //"\t */\n" +
                //"\tprivate final java.util.HashSet<" + contextObjClassName + "> inner" + contextObjName + "Set;\n\n"
                ;
            
        final String constructorStr =
                generateConstructorStr(
                        predicateExpression ,
                        contextObjClassName ,
                        contextObjName ,
                        setConstraintFileName
                        //safememberSet
                        );

            final String testMethodStr =
                generateTestMethodStr(
                        predicateExpression ,
                        contextObjClassName ,
                        contextObjName );

            final String safeOperationsStr =
                    AbstractConstraintCodeGenerator.generateSafeOperationsStr(
                            //switchablePredicate
                            setConstraintDefinition.predicate.lineNr ,
                            setConstraintDefinition.predicate ,
                            setConstraintDefinition.safeOperationArr ,
                            contextObjName );

        classStrBldr.append( "\n" );

        classStrBldr.append( "/**\n" );
        classStrBldr.append( " * Set constraint class of " + contextObjClassName + ".\n" );
        classStrBldr.append( " * <pre>" + predicateExpression.toString() + ".</pre>\n" );
        classStrBldr.append( " * Generated by {@link " + codegeneratorClassName + "}.\n" );
        
        classStrBldr.append( " * Line-Number " + predicateExpression.lineNr + ".\n" );

        classStrBldr.append( " */\n" );

        classStrBldr.append( "public final class " + setConstraintFileName + "\n" );
        classStrBldr.append( "{\n" );
        classStrBldr.append( contextObjMemberStr );
        //classStrBldr.append( safememberStr );
        //classStrBldr.append( safesetStr );
        classStrBldr.append( constructorStr );
        classStrBldr.append( testMethodStr );
        //classStrBldr.append( convertMethodsStr );
        //classStrBldr.append( constraintSafeSwitchClassStr );
        classStrBldr.append( safeOperationsStr );
        classStrBldr.append( "}" );

        final boolean isSaved =
                AbstractConstraintCodeGenerator.saveFileIfChanged(
                        writeToDisc ,
                        classStrBldr.toString() ,
                        srcDirPackagePathStr +
                        File.separator +
                        setConstraintFileName +
                        ".java" ,
                        predicateExpression.lineNr );

        return setConstraintFileName;
    }

    /**
     * Methode zum Erzeugen des Konstruktors für
     * eine Constraint-Klasse.
     *
     * @param predicateExpression aktuell zu generierende Constraint-Expression
     * @param safememberSet SafeMember
     * @return String mit dem Java-Code der erzeugten Konstruktoren
     */
    private static <CT> String generateConstructorStr(
            final Predicate<CT> predicateExpression ,
            final String contextObjClassName ,
            final String contextObjName ,
            final String setConstraintFileName
            //final HashSet<SafeMember> safememberSet
            )
    {
        final StringBuilder buff = new StringBuilder();

        buff.append( "\t/**\n" );
        buff.append( "\t * Constructor.\n" );
        buff.append( "\t * \n" );
        buff.append( "\t * @param " + contextObjName + "Set current context object\n" );
        buff.append( "\t * @throws IllegalArgumentException if constraint violated\n" );
        //buff.append( "\t * @throws Exception if an error occurs\n" );
        buff.append( "\t */\n" );

        buff.append( 
                "\tpublic " +
                setConstraintFileName +
                "(\n" );
        buff.append( "\t\t\tfinal java.util.HashSet<? extends " + contextObjClassName + "> " + contextObjName + "Set )\n" );
        //buff.append( "\tthrows Exception\n" );
        buff.append( "\t{\n" );

        /*
         * Prüfen, ob der übergebene Parameter zulässig ist
         */
        buff.append( "\t\tif ( ! " );

        //buff.append(
        //        generateTestConstraintExpressionStr(
        //                predicateExpression ,
        //                "\t\t\t\t" ) );
        // statt Wiederholung aller Sub-Prädikate einfach Aufruf der statischen test-Methode
        buff.append(
                "test( " +
                contextObjName + "Set" +
                " )" );

        buff.append( " )\n" );
        buff.append( "\t\t{\n" );
        //buff.append( "\t\t\tthrow new IllegalArgumentException( \"constraint violation: \" + String.valueOf( " + CONTEXT_OBJ_NAME + " ) );\n" );
        buff.append( "\t\t\tthrow new IllegalArgumentException( \"constraint violation\" );\n" );
        buff.append( "\t\t}\n" );

        //inner wird nicht gebraucht: buff.append( "\t\tthis.inner" + contextObjName + "Set = new java.util.HashSet( " + contextObjName + "Set );\n" );
        buff.append( "\t\tthis." + contextObjName + "Set = new " + ReadOnlySetAdaptor.class.getName() + "( " + contextObjName + "Set );\n" );

        //for ( final SafeMember safeMember : safememberSet )
        //{
        //    buff.append( "\t\tthis." + safeMember.name + " = (" + safeMember.typStr + ") " + contextObjName + safeMember.contextObjMemberOrGetterStr + ";\n" );
        //}

        buff.append( "\t}\n\n" );

        return buff.toString();
    }

    /**
     * Methode zum Erzeugen der test-Methode für
     * eine Constraint-Klasse.
     *
     * @param predicateExpression aktuell zu generierende Constraint-Expression
     * @param <CT> Type-Parameter Kontext-Objekt-Typ
     * @return String mit dem Java-Code der erzeugten test-Methode
     */
    private static <CT> String generateTestMethodStr(
            final Or<CT> predicateExpression ,
            final String contextObjClassName ,
            final String contextObjName )
    {
        final StringBuilder buff = new StringBuilder();

        buff.append( "\t/**\n" );
        buff.append( "\t * Test method.\n" );
        buff.append( "\t * \n" );
        buff.append( "\t * @param " + contextObjName + "Set current context set object\n" );
        buff.append( "\t * @return constraint expression satisfied or not\n" );
        //buff.append( "\t * @throws Exception if an error occurs\n" );
        buff.append( "\t */\n" );

        buff.append( "\tpublic static boolean test(\n" );
        buff.append( "\t\t\tfinal java.util.HashSet<? extends " + contextObjClassName + "> " + contextObjName + "Set )\n" );
        //buff.append( "\tthrows Exception\n" );
        buff.append( "\t{\n" );

        /*
         * Prüfen, ob der übergebene Parameter die Constraint-Expression erfüllt
         */
        buff.append( "\t\treturn " );

        buff.append(
                generateTestConstraintExpressionStr(
                        predicateExpression ,
                        contextObjName ,
                        "\t\t\t\t" ) );

        buff.append( ";\n" );

        buff.append( "\t}\n\n" );

        return buff.toString();
    }

    /**
     * @param predicateExpression aktuell zu generierende Constraint-Expression
     * @param <CT> Type-Parameter Kontext-Objekt-Typ
     * @param tabStr Tabulator(Einrückung)-String, wird rekursiv vergrössert
     * @return String mit dem Java-Code der erzeugten Test-Constraint-Expression
     */
    private static <CT> String generateTestConstraintExpressionStr(
            final Or<CT> predicateExpression ,
            final String contextObjName ,
            final String tabStr )
    {
        final SeparatedBuffer sepBuff = new SeparatedBuffer( " ||\n" + tabStr );

        // Prüfung ob alle erwarteten Werte im Set enthalten sind
        for ( final Predicate<CT> subOrPredicate : predicateExpression )
        {
            final SafesetPrimitivPredicate<CT, ?> safesetPred = (SafesetPrimitivPredicate<CT, ?>) subOrPredicate;

            sepBuff.add(
                    contextObjName + "Set.contains( " +
                    safesetPred.safeSetValue().toJavaString() +
                    " )" );
        }
        
        final String containsJavacodeStr = "( " + sepBuff + " )";

        // Prüfung auf Größe des Set  um zu verhindern, dass mehr Werte als erwartet enthalten sind
        final String containsAndCheckSizeJavacodeStr =
                containsJavacodeStr +
                " &&\n" + tabStr +
                contextObjName + "Set.size() == " +
                predicateExpression.size();

        return "( " + containsAndCheckSizeJavacodeStr + " )";
    }

}
